
\documentclass[a4paper, 10pt]{article}


\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[OT4]{fontenc}
\usepackage{geometry}
\usepackage{ulem}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[section]{placeins}
\usepackage{amsmath}

\RequirePackage{url}


\setlength{\parindent}{0cm}
\setlength{\parskip}{3mm plus1mm minus1mm}

\geometry{verbose,a4paper,tmargin=2.3cm,bmargin=2.3cm,lmargin=2.4cm,rmargin=2.4cm}
\usepackage{graphicx} % wstawianie obrazkow


%%%%%%%%%%%%%%%%%%%%%%Do Pseudokodu%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\algorithmicrequire}{\textbf{Dane wejściowe:}}
\renewcommand{\algorithmicensure}{\textbf{Inicjalizacja:}}
\renewcommand{\algorithmicend}{\textbf{end}}
\renewcommand{\algorithmicif}{\textbf{if}}
\renewcommand{\algorithmicthen}{\textbf{then}}
\renewcommand{\algorithmicelse}{\textbf{else}}
\renewcommand{\algorithmicelsif}{\algorithmicelse\ \algorithmicif}
\renewcommand{\algorithmicendif}{\algorithmicend\ \algorithmicif}
\renewcommand{\algorithmicfor}{\textbf{for}}
\renewcommand{\algorithmicforall}{\textbf{for all}}
\renewcommand{\algorithmicdo}{\textbf{do}}
\renewcommand{\algorithmicendfor}{\algorithmicend\ \algorithmicfor}
\renewcommand{\algorithmicwhile}{\textbf{while}}
\renewcommand{\algorithmicendwhile}{\algorithmicend\ \algorithmicwhile}
\renewcommand{\algorithmicloop}{\textbf{loop}}
\renewcommand{\algorithmicendloop}{\algorithmicend\ \algorithmicloop}
\renewcommand{\algorithmicrepeat}{\textbf{repeat}}
\renewcommand{\algorithmicuntil}{\textbf{until}}
\renewcommand{\algorithmicprint}{\textbf{print}}
\renewcommand{\algorithmicreturn}{\textbf{Wyjście:}}
\renewcommand{\algorithmictrue}{\textbf{true}}
\renewcommand{\algorithmicfalse}{\textbf{false}}

\floatname{algorithm}{}
\renewcommand\thealgorithm{}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\title{{\bf {Grafy i sieci}} \\ {\large Sprawozdanie 2}}
\date{\today}
\author{Filip Nabrdalik \\Agata Taraszkiewicz}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\bibliographystyle{alpha}
%%%%%%%

\maketitle 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\ang}[1]{(ang. {\em #1}\/)}
\newcommand{\e}[1]{{\em #1}\/}





\section{Treść zadania}

{\bf{Zadanie}}

Porównanie algorytmów znajdowania minimalnego drzewa rozpinającego.

Wybrać, zaimplementować i przebadać co najmniej dwa algorytmy znajdowania minimalnego drzewa rozpinającego w grafie nieskierowanym. 

 

\section{Opis badanych algorytmów}

Do eksperymentów badawczych zostały wybrane trzy zachłanne algorytmy znajdowania minimalnego drzewa rozpinającego: Kruskalla, Prima oraz
Borůvki.

	\subsection{Algorytm Prima}
%http://www.comp.dit.ie/rlawlor/alg_ds/mst/prim.pdf
Algorytm Prima został opracowany w 1930 roku przez Vojtěcha Jarníka. Algorytm znajduje minimalne drzewo rozpinające w spójnym, nieskierowanym grafie ważonym. Należy on do grupy algorytmów zachłannych.
\begin{algorithm}
\caption{{\bf Algorytm Prima}, znajdowanie MST}
\begin{algorithmic}[!h]
\REQUIRE Spójny graf $G=(V,E)$ ,$V \neq \emptyset$. 
\ENSURE $E_{new}=\{\}$ , $V_{new}=\{x\}$, gdzie $x$ jest wierzchołkiem początkowym należącym do $V$, a $E_new$ pustym zbiorem krawędzi.
\WHILE{$V_{new} \neq V$}
\STATE \textbullet{\hspace{0.5cm} Wybierz krawędź $(u,v)$ o najmniejszej wadze taką, że $u \in V_{new}$ i $v \notin V_{new}$.}
\STATE \textbullet{\hspace{0.5cm} Dodaj wierzchołek $v$ do $V_{new}$, a krawędź  $(u,v)$ do $E_{new}$.}   
\ENDWHILE
\RETURN $E_{new}$ oraz $V_{new}$ opisujące minimalne drzewo rozpinające grafu $G$. 
\end{algorithmic}
\end{algorithm}	
\FloatBarrier

 Ze zbioru wierchołków $V$ w grafie, wybierany jest jeden, który będzie początkiem drzewa rozpinającego. Następnie do drzewa dodawana jest   
kolejna krawędź - wybierana z krawędźi o najmiejszej wadze, łącząca wierzchołki w drzewie z wierchołkami spoza dzrewa. Krok ten jest powtarzany do uzyskania MST.

	
	\subsection{Algorytm Kruskala}
	
%http://www.comp.dit.ie/rlawlor/Alg_DS/MST/Kruskal.pdf

Algorytm Kruskala został opublikowany w 1956 roku przez Josepha Kruskala. Algorytm znajduje minimalne drzewo rozpinające dla spójnego grafu ważonego. Należy
on do grupy algorytmów zachłannych. 

\begin{algorithm}
\caption{{\bf Algorytm Kruskala}, znajdowanie MST - do opisu użyta \textit{struktura zbiorów rozłącznych}}
\begin{algorithmic}[!h]
\REQUIRE Spójny graf $G=(V,E)$ ,$V \neq \emptyset$. 
\ENSURE $A=\emptyset$ zbiór zawierający krawędzie MST
\FORALL{$v \in V$} 
\STATE{$MAKE-SET(v)$} 
\ENDFOR 
\FORALL{ $(u,v) \in E$, z listy krawędzi posortowanych rosnąco}
\IF{$FIND-SET(u) \neq FIND-SET(v)$} 
\STATE{$A = A \cup \{(u, v)\}$} 
\STATE{$UNION(u,v)$}
\COMMENT{połączenie drzew $u$ i $v$}
\ENDIF
\ENDFOR 
\RETURN Zbiór $A$ opisujący minimalne drzewo rozpinające grafu $G$.
\end{algorithmic}
\end{algorithm}
\FloatBarrier

Budowany jest las w którym każdy wierzchołek stanowi oddzielne drzewo oraz zbiór zawierający wszyskie krawędzie grafu.
Następnie ze zbioru usuwana jest krawędź o najmniejszej wadze, jeśli krawędź łączy dwa oddzielne drzewa w lesie	to należy te drzewa połączyć w jedno za pomocą
krawędzi. W przeciwnym wypadku krawędź jest odrzucana. Krok ten jest powtarzany do uzyskania MST.

	\subsection{Algorytm Borůvki}
	
%http://sajun.org/index.php/Boruvka%27s_algorithm  

Algorytm Borůvki został opublikowany przez Otakara Borůvkę w 1926 roku jako metoda efektywnej konstrukcji sieci 
energetycznych. Algorytm znajduje minimalne drzewo rozpinające dla spójnego grafu nieskierowanego i jest algorytmem zachłannym.


	
\begin{algorithm}
\caption{{\bf Algorytm Borůvki}, znajdowanie MST}
\begin{algorithmic}[!h]
\REQUIRE Spójny graf $G=(V,E)$ ,$V \neq \emptyset$. 
\ENSURE $L=(V,\emptyset)$, graf złożony tylko z wierzchołków $V$
\WHILE{$L$ nie jest połączony, tzn. jest lasem wiecej niż jednego drzewa $V$}
\FORALL{  $T \in L$, gdzie T jest drzewem} 
\STATE \textbullet{\hspace{0.5cm} Znajdź krawędź o najmiejszej wadze w grafie $G$ taką, że łączy ona wierchołek w drzewie $T$ z wierchołkiem nie należącym do $T$.}
\STATE \textbullet{\hspace{0.5cm} Dodaj krawędź do $L$ redukując ilość drzew w $T$ o jeden.}
\ENDFOR 
\ENDWHILE
\RETURN $L$ opisujący MST.
\end{algorithmic}
\end{algorithm}

\FloatBarrier

Wagi krawędzi powinny być rózne, jeśli są jednak takie same to można je rozróżniać przyporządkowujac im odpowiednie etykiety.
Z krawędzi grafu tworzony jest las, taki że kazda krawędź tworzy oddzielne drzewo. Następnie póki las ma więcej niż jeden komponent $C$, dla każdego
z komponentów powtzarzany jest następujący krok: tworzony jest pusty zbiór wierchołków $S$, następnie dla każdej krawędzi występującej w komponencie znajdowana
jest krawędź o najmniejszej wadze łącząca wirzchołek z $C$ z wierchołakiem spoza $C$ i dodawana jest do zbioru krawędzi $S$. Następnie krawędź o najmniejszej wadze ze zbioru
$S$ dodawana jest do lasu.
\section{Planowana złożoność obliczeniowa i struktury danych}

We wszystkich przedstawionych algorytmach sortowanie krawędzi rosnąco pochłania 
najwięcej czasu. Złożoność obliczeniowe dla algorytmów Borůvki i Kruskala wynosi
 ${\bf O}(|E| log |E|)$. Natomiast dla algorytmu Prima w zależności od implementacji struktur danych:

\begin{itemize}
\item{macierz sąsiedstwa ${\bf O}(V^2)$,} 
\item{lista sąsiedstwa i kopiec binarny ${\bf O}((|V| + |E|) log |V|) = {\bf O}(|E| log |V|)$,}
\item{lista sąsiedstwa i kopiec Fibonacciego  	${\bf O}(|E| + |V| log |V|)$.} 
\end{itemize}


Do reprezentacji grafu użyte zostaną listy sąsiedztwa dla poszczególnych wierzchołków. Struktura
{\it TNode}, reprezentująca wierchołek:

\begin{tabular}{|l|c|c|}
	\hline 
  {\bf Typ} & {\bf Opis} & {\bf Rozmiar [bajt]}\\
  \hline 
  \it{uint16\_t node\_id} & identyfikator węzła & 2 \\
  \hline
  \it{ uint8\_t state} & zmiennna pomocnicza  &  1 \\
  \hline
  \it{ struct TNode* next} & następny element na liście & 4 lub 8 \\
  \hline 
\end{tabular} 

Struktura {\it TGraph}, gdzie kolejne indeksy tablicy to odpowiednio kolejne identyfikatory węzłów:

\begin{tabular}{|l|c|c|}
\hline {\bf Typ} & {\bf Opis} & {\bf Rozmiar [bajt]}\\
  \hline 
   \it{struct TNode* L[MAX\_UNIT16]  } & lista sąsiedztwa & MAX\_UNIT16 * 4 lub 8 \\
  \hline
\end{tabular} 

Można oszacować zużycie pamięci przez graf $G=(V,E)$ dla 32 bitowej architektury procesora $\text{MAX\_UNIT16}\times4+7\times|E|$ bajtów.



\section{Założenia programu}
Grafy do testowania zadane są w postaci plików tekstowych, gdzie pierwsza 
i druga kolumna zawierają identyfikator 2 różnych wierzchołków
grafu pomiędzy którymi istnieje krawędź, a trzecia kolumna reprezentuje
wagę krawędzi. Dla wszystkich algorytmów, konieczne jest spełnienia warunku spójnosci grafu, w związku z 
tym dane wejściowe powinny reprezentować nieskierowane grafy spójne. 


Górnym ograniczeniem na liczbę wierchołków jest typ danych uint16\_t
dla którego maksymalna wartość to 65535, jest ona zarazem najwyższym dostępnym
identyfikatorem węzła. Dodatkowo podczas testów mierzony bedzie czas wykonania algorytmu
w sekundach oraz ilość pamieci wykorzystywana przez proces. Jeśli zostanie przekroczony
pewien empirycznie wyznaczony czas wykonania, algorytm zostanie przerwany. 







\section{Projekt testów}
%testy dla grafów w zazleznosci od ich gestosci
	
	





%BIBLIOGRAFIA
\nocite{*}
\bibliography{bibliografia}


\end{document}


