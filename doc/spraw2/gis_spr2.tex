
\documentclass[a4paper, 10pt]{article}


\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[OT4]{fontenc}
\usepackage{geometry}
\usepackage{ulem}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[section]{placeins}

\RequirePackage{url}


\setlength{\parindent}{0cm}
\setlength{\parskip}{3mm plus1mm minus1mm}

\geometry{verbose,a4paper,tmargin=2.4cm,bmargin=2.4cm,lmargin=2.4cm,rmargin=2.4cm}
\usepackage{graphicx} % wstawianie obrazkow


%%%%%%%%%%%%%%%%%%%%%%Do Pseudokodu%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\algorithmicrequire}{\textbf{Dane wejściowe:}}
\renewcommand{\algorithmicensure}{\textbf{Inicjalizacja:}}
\renewcommand{\algorithmicend}{\textbf{end}}
\renewcommand{\algorithmicif}{\textbf{if}}
\renewcommand{\algorithmicthen}{\textbf{then}}
\renewcommand{\algorithmicelse}{\textbf{else}}
\renewcommand{\algorithmicelsif}{\algorithmicelse\ \algorithmicif}
\renewcommand{\algorithmicendif}{\algorithmicend\ \algorithmicif}
\renewcommand{\algorithmicfor}{\textbf{for}}
\renewcommand{\algorithmicforall}{\textbf{for all}}
\renewcommand{\algorithmicdo}{\textbf{do}}
\renewcommand{\algorithmicendfor}{\algorithmicend\ \algorithmicfor}
\renewcommand{\algorithmicwhile}{\textbf{while}}
\renewcommand{\algorithmicendwhile}{\algorithmicend\ \algorithmicwhile}
\renewcommand{\algorithmicloop}{\textbf{loop}}
\renewcommand{\algorithmicendloop}{\algorithmicend\ \algorithmicloop}
\renewcommand{\algorithmicrepeat}{\textbf{repeat}}
\renewcommand{\algorithmicuntil}{\textbf{until}}
\renewcommand{\algorithmicprint}{\textbf{print}}
\renewcommand{\algorithmicreturn}{\textbf{Wyjście:}}
\renewcommand{\algorithmictrue}{\textbf{true}}
\renewcommand{\algorithmicfalse}{\textbf{false}}

\floatname{algorithm}{}
\renewcommand\thealgorithm{}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\title{{\bf {Grafy i sieci}} \\ {\large Sprawozdanie 2}}
\date{\today}
\author{Filip Nabrdalik \\Agata Taraszkiewicz}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\bibliographystyle{alpha}
%%%%%%%

\maketitle 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\ang}[1]{(ang. {\em #1}\/)}
\newcommand{\e}[1]{{\em #1}\/}





\section{Treść zadania}

{\bf{Zadanie}}

Porównanie algorytmów znajdowania minimalnego drzewa rozpinającego.

Wybrać, zaimplementować i przebadać co najmniej dwa algorytmy znajdowania minimalnego drzewa rozpinającego w grafie nieskierowanym. 

 

\section{Opis badanych algorytmów}

	\subsection{Algorytm Prima}
%http://www.comp.dit.ie/rlawlor/alg_ds/mst/prim.pdf

\begin{algorithm}
\caption{{\bf Algorytm Prima}, znajdowanie MST}
\begin{algorithmic}[!h]
\REQUIRE Spójny graf $G=(V,E)$ ,$V \neq \emptyset$. 
\ENSURE $E_{new}=\{\}$ , $V_{new}=\{x\}$, gdzie $x$ jest wierzchołkiem początkowym należącym do $V$, a $E_new$ pustym zbiorem krawędzi.
\WHILE{$V_{new} \neq V$}
\STATE \textbullet{\hspace{0.5cm} Wybierz krawędź $(u,v)$ o najmniejszej wadze taką, że $u \in V_{new}$ i $v \notin V_{new}$.}
\STATE \textbullet{\hspace{0.5cm} Dodaj wierzchołek $v$ do $V_{new}$, a krawędź  $(u,v)$ do $E_{new}$.}   
\ENDWHILE
\RETURN $E_{new}$ oraz $V_{new}$ opisujące minimalne drzewo rozpinające grafu $G$. 
\end{algorithmic}
\end{algorithm}	
	
	\subsection{Algorytm Kruskalla}
	
	
	
\begin{algorithm}
\caption{{\bf Algorytm Kruskalla}, znajdowanie MST - do opisu użyta \textit{struktura zbiorów rozłącznych}}
\begin{algorithmic}[!h]
\REQUIRE Spójny graf $G=(V,E)$ ,$V \neq \emptyset$. 
\ENSURE $A=\emptyset$ zbiór zawierający krawędzie MST
\FORALL{$v \in V$} 
\STATE{$MAKE-SET(v)$} 
\ENDFOR 
\FORALL{ $(u,v) \in E$, z listy krawędzi posortowanych rosnąco}
\IF{$FIND-SET(u) \neq FIND-SET(v)$} 
\STATE{$A = A \cup \{(u, v)\}$} 
\STATE{$UNION(u,v)$}
\COMMENT{połączenie drzew $u$ i $v$}
\ENDIF
\ENDFOR 
\RETURN Zbiór $A$ opisujący minimalne drzewo rozpinające grafu $G$.
\end{algorithmic}
\end{algorithm}
\FloatBarrier


	\subsection{Algorytm Borůvki}
	
%http://sajun.org/index.php/Boruvka%27s_algorithm
	
\begin{algorithm}
\caption{{\bf Algorytm Borůvki}, znajdowanie MST}
\begin{algorithmic}[!h]
\REQUIRE Spójny graf $G=(V,E)$ ,$V \neq \emptyset$. 
\ENSURE $L=(V,\emptyset)$, graf złożony tylko z wierzchołków $V$
\WHILE{$L$ nie jest połączony, tzn. jest lasem wiecej niż jednego drzewa $V$}
\FORALL{  $T \in L$, gdzie T jest drzewem} 
\STATE \textbullet{\hspace{0.5cm} Znajdź krawędź o najmiejszej wadze w grafie $G$ taką, że łączy ona wierchołek w drzewie $T$ z wierchołkiem nie należącym do $T$.}
\STATE \textbullet{\hspace{0.5cm} Dodaj krawędź do $L$ redukując ilość drzew w $T$ o jeden.}
\ENDFOR 
\ENDWHILE
\RETURN $L$ opisujący MST.
\end{algorithmic}
\end{algorithm}


\FloatBarrier

\section{Planowana złożoność obliczeniowa}
\section{Struktury danych}
\section{Założenia programu}
\section{Projekt testów}
	
	





%BIBLIOGRAFIA
\nocite{*}
\bibliography{bibliografia}


\end{document}


